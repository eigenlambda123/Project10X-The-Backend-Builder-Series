from django.test import TestCase, RequestFactory
from django.contrib.auth.models import User
from expenses.models import Category, Transactions
from expenses.serializers import CategorySerializer, TransactionsSerializer

class CategorySerializerTest(TestCase):
    """
    """
    def setUp(self):
        """
        Set up test dependencies before each test method.

        Initializes a RequestFactory instance for simulating HTTP requests in tests.
        Creates a test user for authentication-related test cases.
        """
        self.factory = RequestFactory() 
        self.user = User.objects.create_user(username='testuser', password='pass') # create test user

    def get_serializer_context(self):
        """
        Returns serializer context with a mock request and test user.
        """
        request = self.factory.get('/') # Create a mock GET request to the root URL
        request.user = self.user # Assign the test user to the request
        return {'request': request} # Return context dictionary with the request
    
    def test_valid_data_creates_category(self):
        """
        Test if creating a Category with valid data is working correctly
        """

        data = {'name': 'Food'}  # Input data for the Category
        serializer = CategorySerializer(data=data, context=self.get_serializer_context())  # Initialize serializer with data and context
        self.assertTrue(serializer.is_valid(), serializer.errors)  # Assert that the serializer validates the input data
        category = serializer.save()  # Save the validated data and create a Category instance
        self.assertEqual(category.name, 'Food')  # Assert the category name is set correctly
        self.assertEqual(category.user, self.user)  # Assert the category user is set to the test user
        
    def test_missing_name_fails(self):
        """
        Test if creating a Category with invalid data (missing name) is sending an error
        """

        data = {'name': ''} # missing name 
        serializer = CategorySerializer(data=data, context=self.get_serializer_context()) # Initialize serializer with data and context
        self.assertFalse(serializer.is_valid()) # check if data is valid (should be false)
        self.assertIn('name', serializer.errors) # checks that the string 'name' is a key in the serializer.errors dictionary

    def test_slug_is_autogenerated(self):
        """
        Test if slug auto generate via given name
        """
        data = {'name': 'Travel Budget'} # Input data
        serializer = CategorySerializer(data=data, context=self.get_serializer_context())  # Initialize serializer with data and context
        self.assertTrue(serializer.is_valid(), serializer.errors)  # checks that the serializer's data is valid. If serializer.is_valid() returns False, the test will fail and display serializer.error
        category = serializer.save() # save the data
        self.assertEqual(category.slug, 'travel-budget')  # should generate the following slug


    def test_duplicate_name_for_same_user_fails(self):
        """
        Test that creating a Category with a duplicate name for the same user returns a validation error.
        """
        # 
        Category.objects.create(name='Food', user=self.user) # create new cateogry 
        data = {'name': 'Food'}  # attemp to create another category with the same name for the same user
        serializer = CategorySerializer(data=data, context=self.get_serializer_context())  # Initialize serializer with duplicate data
        self.assertIn('non_field_errors', serializer.errors)  # Check that a non-field error is returned for the uniqueness violation
